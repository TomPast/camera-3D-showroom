/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: AleixoAlonso (https://sketchfab.com/AleixoAlonso)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/canon-at-1-retro-camera-9de66868d0f240e985da00c9480bfc82
Title: Canon AT-1 Retro Camera
*/

import React, { useRef } from "react";
import { useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useContext, useEffect } from "react";
import { AppContext } from "../../context/appContext";
import { SECTIONS } from "../../constants/sections";

export default function CameraModel(props) {
  const { nodes, materials, ...model } = useGLTF("/models/canon.glb");
  const { setScrollContext, setActiveSection } = useContext(AppContext);

  useEffect(() => {
    const handleMenuClick = (event) => {
      if (event.detail && typeof event.detail.sectionIndex === "number") {
        scrollTo(event.detail.sectionIndex);
      }
    };

    window.addEventListener("menuClick", handleMenuClick);

    return () => {
      window.removeEventListener("menuClick", handleMenuClick);
    };
  }, [scrollTo]);

  materials.CAM0001_Textures.depthWrite = true;
  materials.CAM0001_Textures.depthTest = true;

  const groupRef = useRef();
  const scroll = useScroll();

  useEffect(() => {
    setScrollContext(scroll);
  }, [scroll]);

  useFrame((state, delta) => {
    const scrollOffset = scroll.offset;
    const sectionCount = SECTIONS.length;

    // Calculer l'index avec une transition plus progressive pour le menu
    const rawIndex = scrollOffset * (sectionCount - 1);
    const menuSectionIndex = Math.round(Math.min(rawIndex, sectionCount - 1));
    setActiveSection(menuSectionIndex);

    // Pour les animations, utiliser l'index non arrondi
    const currentSectionIndex = Math.floor(rawIndex);
    const currentSection = SECTIONS[currentSectionIndex];
    const nextSection =
      SECTIONS[Math.min(currentSectionIndex + 1, sectionCount - 1)];

    if (!currentSection || !nextSection) return;

    // Calculer le facteur de progression entre les sections pour l'animation
    const sectionProgress = smoothstep(
      0.2,
      0.8,
      rawIndex - currentSectionIndex
    );

    // Interpolate camera position and rotation
    state.camera.position.x = lerp(
      currentSection.cameraPosition.position.x,
      nextSection.cameraPosition.position.x,
      sectionProgress
    );
    state.camera.position.y = lerp(
      currentSection.cameraPosition.position.y,
      nextSection.cameraPosition.position.y,
      sectionProgress
    );
    state.camera.position.z = lerp(
      currentSection.cameraPosition.position.z,
      nextSection.cameraPosition.position.z,
      sectionProgress
    );

    // Handle object position and rotation if defined in sections
    if (groupRef.current && currentSection.objectPosition) {
      const nextObjectPosition =
        nextSection.objectPosition || currentSection.objectPosition;

      // Object rotation
      groupRef.current.rotation.x = lerp(
        currentSection.objectPosition.rotation.x,
        nextObjectPosition.rotation.x,
        sectionProgress
      );
      groupRef.current.rotation.y = lerp(
        currentSection.objectPosition.rotation.y,
        nextObjectPosition.rotation.y,
        sectionProgress
      );
      groupRef.current.rotation.z = lerp(
        currentSection.objectPosition.rotation.z,
        nextObjectPosition.rotation.z,
        sectionProgress
      );
    }

    // Handle lookAt transition
    if (
      currentSection.cameraPosition.lookAt ||
      nextSection.cameraPosition.lookAt
    ) {
      const defaultLookAt = { x: 3, y: 0.5, z: 0 };
      const currentLookAt =
        currentSection.cameraPosition.lookAt || defaultLookAt;
      const nextLookAt = nextSection.cameraPosition.lookAt || defaultLookAt;

      const lookAtX = lerp(currentLookAt.x, nextLookAt.x, sectionProgress);
      const lookAtY = lerp(currentLookAt.y, nextLookAt.y, sectionProgress);
      const lookAtZ = lerp(currentLookAt.z, nextLookAt.z, sectionProgress);

      state.camera.lookAt(lookAtX, lookAtY, lookAtZ);
    } else {
      state.camera.lookAt(3, 0.5, 0);
    }
  });

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <group name="#CAM0001_Body" rotation={[-Math.PI / 2, 0, 0]}>
        <mesh
          name="#CAM0001_Body_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Body_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
        />
        <mesh
          name="#CAM0001_Battery_Check_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={
            nodes["#CAM0001_Battery_Check_#CAM0001_Textures_0"].geometry
          }
          material={materials.CAM0001_Textures}
          position={[0.05, 0.001, 0.072]}
        />

        <mesh
          name="#CAM0001_Spool_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Spool_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[0.05, 0.001, 0.075]}
        />
        <mesh
          name="#CAM0001_Film_Advance_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Film_Advance_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[-0.057, 0.001, 0.077]}
        ></mesh>
        <mesh
          name="#CAM0001_Shutter_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Shutter_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[-0.035, -0.006, 0.076]}
        />
        <mesh
          name="#CAM0001_Shutter_Speed_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={
            nodes["#CAM0001_Shutter_Speed_#CAM0001_Textures_0"].geometry
          }
          material={materials.CAM0001_Textures}
          position={[-0.057, 0.001, 0.073]}
        ></mesh>
      </group>
    </group>
  );
}

useGLTF.preload("/models/canon.glb");

// Helper function for linear interpolation
function lerp(start, end, t) {
  return start * (1 - t) + end * t;
}

// Ajouter cette fonction en bas du fichier
function smoothstep(min, max, value) {
  const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
  return x * x * (3 - 2 * x);
}
