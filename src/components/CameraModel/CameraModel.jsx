/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: AleixoAlonso (https://sketchfab.com/AleixoAlonso)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/canon-at-1-retro-camera-9de66868d0f240e985da00c9480bfc82
Title: Canon AT-1 Retro Camera
*/

import React, { useRef } from "react";
import { useGLTF, useScroll } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";
import { useContext, useEffect } from "react";
import { AppContext } from "../../context/appContext";

export const SECTIONS = [
  {
    content: (
      <>
        <h2>Canon AT-1</h2>
        <p>
          Released in 1977, the Canon AT-1 is a 35mm SLR camera designed as an
          affordable, manual-focus alternative to the AE-1. With its mechanical
          reliability, robust build, and timeless design, it's a favorite among
          film photography enthusiasts and collectors.
        </p>
        <p>
          This camera offers a perfect blend of manual control and mechanical
          reliability, making it one of the most iconic cameras of its time. Its
          sleek, classic design continues to inspire modern-day photographers
          who appreciate the tactile experience of shooting film.
        </p>
        <p>
          While the AT-1 is known for its durability, it's also packed with
          advanced features that make it a joy to use. Whether you're a novice
          or an experienced photographer, the Canon AT-1 offers a truly
          enjoyable shooting experience.
        </p>
      </>
    ),
    cameraPosition: {
      position: { x: 0, y: 1, z: 15 },
    },
    objectPosition: {
      rotation: { x: 0.1, y: 0, z: 0 },
    },
  },
  {
    content: (
      <>
        <h3>Manual Focus System</h3>
        <p>
          The Canon AT-1 features a precise manual focus system, allowing
          photographers to achieve perfect sharpness without relying on
          automation. The focus ring offers smooth and accurate adjustments.
        </p>
        <p>
          This manual system gives photographers complete control over focus,
          allowing them to capture images with great precision, even in
          challenging conditions.
        </p>
        <p>
          The focusing mechanism is smooth and precise, providing instant
          tactile feedback that enhances the overall shooting experience.
        </p>
        <p>
          Additionally, the AT-1's large, bright viewfinder allows for easy
          composition and focusing, making it an excellent choice for
          photographers who appreciate a hands-on approach to their craft.
        </p>
      </>
    ),
    cameraPosition: {
      position: { x: 2, y: 0, z: 12 },
      lookAt: { x: 3, y: 0, z: 0 },

      zoom: 1,
    },
    objectPosition: {
      rotation: { x: Math.PI * 0.5, y: Math.PI * 0.5, z: 0 },
    },
  },
  {
    content: (
      <>
        <h3>Shutter Speed Dial</h3>
        <p>
          The shutter speed dial offers a wide range of speeds from 1/1000 to 2
          seconds, plus a bulb mode for long exposures, perfect for creative
          photography.
        </p>
        <p>
          The AT-1's shutter dial is easy to adjust, offering a precise range of
          exposure times. From freezing fast-moving subjects to capturing
          long-exposure shots in low light, the AT-1 has you covered.
        </p>
        <p>
          Its exposure control system provides flexibility, allowing users to
          shoot in a variety of lighting conditions, while still maintaining
          full control over exposure.
        </p>
        <p>
          Whether you're shooting in bright sunlight or capturing stunning night
          scenes, the AT-1's shutter speed dial ensures your photos come out
          exactly how you envision them.
        </p>
      </>
    ),
    cameraPosition: {
      position: { x: 2, y: 1, z: 15 },
    },
    objectPosition: {
      rotation: { x: Math.PI / 2, y: Math.PI * 1, z: 0 },
    },
  },
  {
    content: (
      <>
        <h3>LED Light Meter Display</h3>
        <p>
          The AT-1 is equipped with an intuitive LED light meter display inside
          the viewfinder, ensuring correct exposure for every shot, even in
          challenging lighting conditions. This feature makes it ideal for both
          beginners and professional photographers looking for precise exposure
          control.
        </p>
        <p>
          The built-in light meter continuously measures the light in the scene
          and displays this information in the viewfinder, helping you adjust
          settings to achieve perfect exposure every time.
        </p>
        <p>
          This feature is incredibly useful in various lighting situations,
          particularly for beginners who may not yet be comfortable with manual
          metering. It's an easy and reliable way to ensure your images are
          correctly exposed without relying on automation.
        </p>
        <p>
          As a bonus, the light meter works even in low light conditions, making
          the Canon AT-1 a versatile camera for any environment.
        </p>
      </>
    ),
    cameraPosition: {
      position: { x: 2, y: 1, z: 15 },
    },
    objectPosition: {
      rotation: { x: 0, y: Math.PI * 1, z: 0 },
    },
  },
  {
    content: (
      <>
        <button> Learn more about Canon AT-1</button>
        <p>
          Interested in the history and technical specifications of the Canon
          AT-1? Click below to learn more about this remarkable camera, its
          place in the world of photography, and how it has shaped the craft for
          over four decades.
        </p>
        <p>
          From its creation to its legacy, the Canon AT-1 continues to inspire
          photographers who value the beauty of film photography and the craft
          of manual control.
        </p>
      </>
    ),
    cameraPosition: {
      position: { x: 0, y: 1, z: 15 },
    },
    objectPosition: {
      rotation: { x: 0.1, y: 0, z: 0 },
    },
  },
];

export default function CameraModel(props) {
  const { nodes, materials, ...model } = useGLTF("/models/canon.glb");
  const { setScrollContext, setActiveSection } = useContext(AppContext);

  useEffect(() => {
    const handleMenuClick = (event) => {
      if (event.detail && typeof event.detail.sectionIndex === "number") {
        scrollTo(event.detail.sectionIndex);
      }
    };

    window.addEventListener("menuClick", handleMenuClick);

    return () => {
      window.removeEventListener("menuClick", handleMenuClick);
    };
  }, [scrollTo]);

  materials.CAM0001_Textures.depthWrite = true;
  materials.CAM0001_Textures.depthTest = true;

  const groupRef = useRef();
  const scroll = useScroll();

  useEffect(() => {
    setScrollContext(scroll);
  }, [scroll]);

  useFrame((state, delta) => {
    const scrollOffset = scroll.offset;
    const sectionCount = SECTIONS.length;

    // Calculer l'index avec une transition plus progressive pour le menu
    const rawIndex = scrollOffset * (sectionCount - 1);
    const menuSectionIndex = Math.round(Math.min(rawIndex, sectionCount - 1));
    setActiveSection(menuSectionIndex);

    // Pour les animations, utiliser l'index non arrondi
    const currentSectionIndex = Math.floor(rawIndex);
    const currentSection = SECTIONS[currentSectionIndex];
    const nextSection =
      SECTIONS[Math.min(currentSectionIndex + 1, sectionCount - 1)];

    if (!currentSection || !nextSection) return;

    // Calculer le facteur de progression entre les sections pour l'animation
    const sectionProgress = smoothstep(
      0.2,
      0.8,
      rawIndex - currentSectionIndex
    );

    // Interpolate camera position and rotation
    state.camera.position.x = lerp(
      currentSection.cameraPosition.position.x,
      nextSection.cameraPosition.position.x,
      sectionProgress
    );
    state.camera.position.y = lerp(
      currentSection.cameraPosition.position.y,
      nextSection.cameraPosition.position.y,
      sectionProgress
    );
    state.camera.position.z = lerp(
      currentSection.cameraPosition.position.z,
      nextSection.cameraPosition.position.z,
      sectionProgress
    );

    // Handle object position and rotation if defined in sections
    if (groupRef.current && currentSection.objectPosition) {
      const nextObjectPosition =
        nextSection.objectPosition || currentSection.objectPosition;

      // Object rotation
      groupRef.current.rotation.x = lerp(
        currentSection.objectPosition.rotation.x,
        nextObjectPosition.rotation.x,
        sectionProgress
      );
      groupRef.current.rotation.y = lerp(
        currentSection.objectPosition.rotation.y,
        nextObjectPosition.rotation.y,
        sectionProgress
      );
      groupRef.current.rotation.z = lerp(
        currentSection.objectPosition.rotation.z,
        nextObjectPosition.rotation.z,
        sectionProgress
      );
    }

    // Handle lookAt transition
    if (
      currentSection.cameraPosition.lookAt ||
      nextSection.cameraPosition.lookAt
    ) {
      const defaultLookAt = { x: 3, y: 0.5, z: 0 };
      const currentLookAt =
        currentSection.cameraPosition.lookAt || defaultLookAt;
      const nextLookAt = nextSection.cameraPosition.lookAt || defaultLookAt;

      const lookAtX = lerp(currentLookAt.x, nextLookAt.x, sectionProgress);
      const lookAtY = lerp(currentLookAt.y, nextLookAt.y, sectionProgress);
      const lookAtZ = lerp(currentLookAt.z, nextLookAt.z, sectionProgress);

      state.camera.lookAt(lookAtX, lookAtY, lookAtZ);
    } else {
      state.camera.lookAt(3, 0.5, 0);
    }
  });

  return (
    <group {...props} dispose={null} ref={groupRef}>
      <group name="#CAM0001_Body" rotation={[-Math.PI / 2, 0, 0]}>
        <mesh
          name="#CAM0001_Body_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Body_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
        />
        <mesh
          name="#CAM0001_Battery_Check_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={
            nodes["#CAM0001_Battery_Check_#CAM0001_Textures_0"].geometry
          }
          material={materials.CAM0001_Textures}
          position={[0.05, 0.001, 0.072]}
        />

        <mesh
          name="#CAM0001_Spool_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Spool_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[0.05, 0.001, 0.075]}
        />
        <mesh
          name="#CAM0001_Film_Advance_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Film_Advance_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[-0.057, 0.001, 0.077]}
        ></mesh>
        <mesh
          name="#CAM0001_Shutter_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={nodes["#CAM0001_Shutter_#CAM0001_Textures_0"].geometry}
          material={materials.CAM0001_Textures}
          position={[-0.035, -0.006, 0.076]}
        />
        <mesh
          name="#CAM0001_Shutter_Speed_#CAM0001_Textures_0"
          castShadow
          receiveShadow
          geometry={
            nodes["#CAM0001_Shutter_Speed_#CAM0001_Textures_0"].geometry
          }
          material={materials.CAM0001_Textures}
          position={[-0.057, 0.001, 0.073]}
        ></mesh>
      </group>
    </group>
  );
}

useGLTF.preload("/models/canon.glb");

// Helper function for linear interpolation
function lerp(start, end, t) {
  return start * (1 - t) + end * t;
}

// Ajouter cette fonction en bas du fichier
function smoothstep(min, max, value) {
  const x = Math.max(0, Math.min(1, (value - min) / (max - min)));
  return x * x * (3 - 2 * x);
}
